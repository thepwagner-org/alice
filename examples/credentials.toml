# Example configuration demonstrating credential injection.
#
# Alice replaces "dummy" tokens with real secrets loaded from env vars or files.
# This allows Bob (the client) to use placeholder tokens that get replaced
# before requests reach upstream.
#
# Test with:
#   REAL_TOKEN=secret123 cargo run -- -c examples/credentials.toml
#   curl --proxy http://localhost:3128 --cacert /tmp/alice-ca.pem \
#        -H "Authorization: Bearer DUMMY_TOKEN" \
#        https://httpbin.org/headers
#
# Using SOPS for encrypted secrets:
#
#   # Create a secrets file (secrets.env)
#   export GITHUB_TOKEN=ghp_xxxx
#   export API_KEY=sk-xxxx
#
#   # Encrypt with SOPS (supports age, PGP, AWS KMS, etc.)
#   sops -e -i secrets.env
#
#   # Run Alice with decrypted env vars
#   sops exec-env secrets.env -- alice -c config.toml
#
# This approach works with any SOPS backend, including hardware tokens
# via age-plugin-yubikey.

[proxy]
listen = "127.0.0.1:3128"

[ca]
cert_path = "/tmp/alice-ca.pem"

[[rules]]
action = "allow"
host = "httpbin.org"

[[rules]]
action = "allow"
host = "*.httpbin.org"

# Credential injection: replace dummy tokens with real secrets
#
# Each credential specifies:
#   - name: identifier for logging
#   - host: glob pattern for which hosts to inject (e.g., "*.github.com")
#   - header: which HTTP header to check/replace
#   - match: the dummy value that triggers replacement
#   - format: how to format the real value (use {value} placeholder)
#   - env: environment variable containing the real secret
#   - file: file path containing the real secret (alternative to env)

[[credentials]]
name = "test-token"
host = "httpbin.org"
header = "Authorization"
match = "Bearer DUMMY_TOKEN"
format = "Bearer {value}"
env = "REAL_TOKEN"

# Example with file-based secret
# [[credentials]]
# name = "api-key"
# host = "api.example.com"
# header = "X-API-Key"
# match = "DUMMY_KEY"
# format = "{value}"
# file = "/run/secrets/api-key"

# Example for GitHub API
# [[credentials]]
# name = "github-token"
# host = "api.github.com"
# header = "Authorization"
# match = "token DUMMY_GITHUB"
# format = "token {value}"
# env = "GITHUB_TOKEN"

# Example: HTTP Basic auth for private registries (Bundler, pip, etc.)
#
# When scheme = "basic", Alice automatically handles base64 encoding/decoding:
# 1. Client sends: Authorization: Basic base64("token:DUMMY_TOKEN")
# 2. Alice decodes, verifies username + match, re-encodes with real secret
# 3. Upstream sees: Authorization: Basic base64("token:<real_secret>")
#
# [[credentials]]
# name = "private-gems"
# host = "pkgs.example.com"
# scheme = "basic"
# username = "token"
# match = "DUMMY_REGISTRY_TOKEN"
# env = "REGISTRY_TOKEN"
